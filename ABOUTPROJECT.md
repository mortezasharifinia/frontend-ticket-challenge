# It's not a challenge, it's more than a challenge.

## Scenario

The scenario of the project is that the user should log in with a valid mobile number and then enter the validation code (as OTP). After that, the user can see the previous and next events, but it should select a current event, others are disabled. When a current event is selected, the stadium plan will be shown. The stadium plan is based on map IDs, if the map IDs are less than 10, the fewer IDs will be generated as unavailable stages, if the map IDs are more than 10 the more IDs will be generated as VIP stage(but it's limited to 10 stages for now). After a stage is chosen, the rows of the stage based on how many sub-arrays are in the map details and seat array will be shown. After selecting the desired seat row, the seats based on data in the sub-array will be shown. The 1 means the seat is reserved and unavailable and the 0 means the seat is available. Whenever the user chose a seat, the ticket will be reserved.

## More Details

### Login
The user hasn't access to other pages without logging in. The user should log in with a valid Iranian mobile number. For now, the mobile number will be set as token (in cookies). It will be expired in 30 minutes. So the user should buy its ticket in 30 minutes. Otherwise, it should be logged in again, and start again the process.

### Booking
The events are categorized into three types: finished, now, and future. The finished event is disabled but with final and detailed match results. The new event is available to buy a ticket. The future event is up coming event and disabled.

### Stadium
The stadium stages are generated by map IDs `(GET /map)` and the chosen stage will be shown its row and seat `(GET /map/<map_id>)`.

### Ticket
The user can buy the ticket after choosing the stage (map_id, x as rows, and y as seat) `POST /map//ticket`. The serial number of the ticket will be generated based on the ticket id, and the stage, row, and seat numbers will be shown as well. Here the cookies will be removed. Here the cookies will be removed. The user should be login again. (Based on a conventional process in sports ticketing, one national number `here with considered a mobile number as a unique id for the user` = one ticket).

## Specification
* token, save as cookies with 30 minutes expired time
* error handled by snack bar
* request time consumption handled by the loader
* retry request twice to get a response
* page transition (fade effect)
* ticket token is shown as a barcode
* principle design is based on morph design `https://morphdesign.io/`



## Challenge
* smooth loading
First of all, for handling big data, the data could be frozen. Because Vue by default makes reactive every first-level property for each object in the array. That can be expensive for large arrays of objects. So, in these cases, we can gain some performance if we prevent Vue from making reactive that list. And we can do that by using `Object.freeze` to the list before adding it to the component. It is done in store > module > booking. Second, When youâ€™re rendering a large collection of data, you might find the browser gets slow when loading. In this case, we need Virtual Scrolling to display a big amount of data efficiently and performantly (virtual scrolling not implemented).

* unit test
Jest is a delightful JavaScript Testing Framework with a focus on simplicity. it's set up for the project, but not any test implemented.


# Default Validation Code Is 123456